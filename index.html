<script>
const canvas = document.getElementById('matrixCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const SYMBOL = "frxEURUSD";
const DERIV_WS = "wss://ws.derivws.com/websockets/v3?app_id=1089";

// Configuration
const CELL_W = 40; // Width of one column
const TOTAL_ROWS = 60;
const MAX_COLS = 7200;
const BAR_SIZE = 30; // Matches CSS var --bar-size

// State
let matrixData = {};
let currentColumn = 0;
let CELL_H = 16; // Calculated dynamically
let ws = null;

// Logic Engine Array (60 Offsets)
const ENGINE = Array.from({ length: 60 }, (_, i) => ({
    id: i,
    bucket_ts: 0,
    open: 0,
    close: 0,
    prev_color: 'Gray',
    prev_streak: 0,
    live_color: 'Gray',
    live_streak: 0,
    history: { Red: {}, Green: {} }
}));

const pad = (n) => String(n).padStart(2, '0');

function processTick(price, epoch) {
    document.getElementById('priceTag').innerText = price.toFixed(5);

    ENGINE.forEach(s => {
        // Calculate the specific 1-minute bucket for this offset
        const bucket = Math.floor((epoch - s.id) / 60) * 60 + s.id;

        if (bucket > s.bucket_ts) {
            // New minute logic for this specific offset
            if (s.bucket_ts !== 0) {
                const color = s.close > s.open ? 'Green' : (s.close < s.open ? 'Red' : 'Gray');
                if (color !== 'Gray') {
                    if (color === s.prev_color) {
                        s.prev_streak++;
                    } else {
                        s.prev_color = color;
                        s.prev_streak = 1;
                    }
                    // Record history
                    s.history[color][s.prev_streak] = (s.history[color][s.prev_streak] || 0) + 1;
                } else {
                    s.prev_streak = 0;
                    s.prev_color = 'Gray';
                }
            }
            s.bucket_ts = bucket;
            s.open = price;
            s.close = price;
        } else {
            // Update current candle
            s.close = price;
        }

        // Live Streak Calculation
        const lColor = s.close > s.open ? 'Green' : (s.close < s.open ? 'Red' : 'Gray');
        if (lColor === 'Gray') {
            s.live_streak = s.prev_streak;
            s.live_color = s.prev_color;
        } else if (lColor === s.prev_color) {
            s.live_streak = s.prev_streak + 1;
            s.live_color = lColor;
        } else {
            s.live_streak = 1;
            s.live_color = lColor;
        }
    });
}

function scanBestWalls() {
    let topWalls = [];
    ENGINE.forEach(s => {
        let bestWall = null;
        let highestScore = -1;

        ['Red', 'Green'].forEach(color => {
            const counts = s.history[color];
            for (let x = 1; x < 20; x++) {
                const currCount = counts[x] || 0;
                const nextCount = counts[x + 1] || 0;

                if (currCount >= 2) {
                    const winRate = (1 - (nextCount / currCount)) * 100;
                    const score = winRate * Math.log10(currCount + 1);

                    if (score > highestScore) {
                        highestScore = score;
                        bestWall = {
                            id: s.id,
                            color: color,
                            level: `X${x}â†’X${x + 1}`,
                            winRate: winRate,
                            count: currCount,
                            score: score,
                            prediction: color === 'Red' ? 'CALL' : 'PUT'
                        };
                    }
                }
            }
        });
        if (bestWall) topWalls.push(bestWall);
    });

    topWalls.sort((a, b) => b.score - a.score);
    renderHunterPanel(topWalls.slice(0, 15));
}

function renderHunterPanel(walls) {
    const container = document.getElementById('hunterList');
    if (!container) return;
    
    container.innerHTML = walls.map(w => `
        <div class="h-row" onclick="openModal(${w.id})">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <span style="color:var(--accent-gold); font-weight:800; font-size:12px;">${pad(w.id)}_${pad(w.id)}</span>
                <span class="pulse-val" style="font-size:11px;">${w.winRate.toFixed(0)}% WIN</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:5px;">
                <span style="color:${w.color === 'Red' ? 'var(--accent-red)' : 'var(--accent-green)'}; font-weight:700; font-size:10px;">${w.level}</span>
                <span style="color:var(--text-dim); font-size:9px;">[ VOL: ${w.count} ]</span>
            </div>
            <div style="margin-top:5px; font-weight:800; font-size:9px; color:var(--accent-gold); letter-spacing:1px;">
                PREDICTION: ${w.prediction}
            </div>
        </div>
    `).join('') || '<div style="padding:10px;text-align:center;color:#444;font-size:10px;">GATHERING DATA...</div>';
}

function handleTick(tick) {
    const now = tick.epoch;
    processTick(tick.quote, now);
    
    // Determine column based on minutes
    currentColumn = Math.floor(now / 60) % MAX_COLS;
    
    if (!matrixData[currentColumn]) matrixData[currentColumn] = {};
    
    // Update live data for this column
    ENGINE.forEach(s => {
        matrixData[currentColumn][s.id] = {
            c: s.live_color[0], // 'R' or 'G' or 'G' (Gray)
            s: s.live_streak
        };
    });
    
    updateUI(); // Updates sidebar numbers
}

// Sidebar Update (Heatmap numbers)
function updateUI() {
    let hS = '', hI = '';
    // We only scan the CURRENT column for sidebar "Live" stats, 
    // or you can scan the whole matrix. Usually live stats = current column.
    const liveColData = matrixData[currentColumn] || {};

    for (let r = 0; r < 60; r++) {
        // Getting max streak from History is hard without iterating everything, 
        // so here we just show the LIVE streak in the sidebar.
        let cell = liveColData[r];
        let rVal = '--', gVal = '--';
        
        if(cell) {
             if(cell.c === 'R') rVal = cell.s;
             if(cell.c === 'G') gVal = cell.s;
        }

        hS += `<div class="streak-row" onclick="openModal(${r})" style="height:${CELL_H}px">
            <div class="streak-col red-side">${rVal}</div>
            <div class="streak-col green-side">${gVal}</div>
        </div>`;
        hI += `<div class="index-cell" style="height:${CELL_H}px">${pad(r)}_${pad(r)}</div>`;
    }
    document.getElementById('col-streak').innerHTML = hS;
    document.getElementById('col-index').innerHTML = hI;
    scanBestWalls();
}

function openModal(sec) {
    const s = ENGINE[sec];
    document.getElementById('modalTitle').innerText = `OFFSET ${pad(sec)} DATA`;
    const render = (obj, clr) => Object.keys(obj).sort((a, b) => b - a).map(k => 
        `<div style="padding:8px; border-bottom:1px solid #222; color:${clr}; font-size:10px;">
            <b>X${k}</b> <span style="float:right">${obj[k]} hits</span>
        </div>`).join('');
    
    document.getElementById('rD').innerHTML = render(s.history.Red, '#ff3b30');
    document.getElementById('gD').innerHTML = render(s.history.Green, '#34c759');
    
    const m = document.getElementById('modal');
    const o = document.getElementById('modalOverlay');
    m.style.display = 'flex';
    o.style.display = 'block';
}

window.closeModal = function() { // Exposed to window for HTML onclick
    document.getElementById('modal').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
}

window.onresize = () => {
    const stage = document.getElementById('stage');
    const dpr = window.devicePixelRatio || 1;
    
    // Set internal resolution matches physical pixels
    canvas.width = stage.clientWidth * dpr;
    canvas.height = stage.clientHeight * dpr;
    
    // Set CSS size matches display size
    canvas.style.width = stage.clientWidth + 'px';
    canvas.style.height = stage.clientHeight + 'px';
    
    ctx.scale(dpr, dpr);
    
    // Calculate Cell Height to fit exactly 60 rows
    CELL_H = stage.clientHeight / 60;
    
    updateUI();
};

function connect() {
    ws = new WebSocket(DERIV_WS);
    ws.onopen = () => {
        ws.send(JSON.stringify({ ticks: SYMBOL, subscribe: 1 }));
    };
    ws.onmessage = (m) => {
        const d = JSON.parse(m.data);
        if (d.tick) handleTick(d.tick);
    };
    ws.onclose = () => setTimeout(connect, 3000);
}

// THE MISSING PIECE: The Drawing Loop
function draw() {
    requestAnimationFrame(draw);

    const dpr = window.devicePixelRatio || 1;
    // Logical Width/Height
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;

    // 1. Clear Screen
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, w, h);

    // 2. Determine Viewport
    // We want the current column to be on the far right.
    const maxVisibleCols = Math.ceil(w / CELL_W) + 1;
    const startCol = currentColumn - maxVisibleCols + 2; 

    // 3. Render Loop
    for (let i = 0; i < maxVisibleCols; i++) {
        // The column index in our data
        const dataColIdx = startCol + i;
        
        // The X position on screen
        const x = i * CELL_W;

        // Skip if negative index (before history started)
        if (dataColIdx < 0) continue;

        // Draw Grid Line (Vertical)
        ctx.strokeStyle = "#1a1a1a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();

        // Get Data for this column
        const colData = matrixData[dataColIdx];

        // Draw Rows (0 to 59)
        for (let row = 0; row < 60; row++) {
            const y = row * CELL_H;
            
            // Draw Grid Line (Horizontal) - only need to do this once per row really, 
            // but doing it here ensures full grid. Optimized: move out of loop if slow.
            if(i===0) {
                ctx.strokeStyle = "#1a1a1a";
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
            }

            if (colData && colData[row]) {
                const cell = colData[row];
                
                // Base colors
                let bg = 'transparent';
                let txt = '#444';

                if (cell.c === 'R') {
                    bg = 'rgba(255, 59, 48, 0.15)';
                    txt = '#ff3b30';
                } else if (cell.c === 'G') {
                    bg = 'rgba(52, 199, 89, 0.15)';
                    txt = '#34c759';
                }

                // Draw Box Background
                ctx.fillStyle = bg;
                ctx.fillRect(x + 1, y + 1, CELL_W - 2, CELL_H - 1);

                // Draw Text
                if (cell.c !== 'G' && cell.c !== 'R') {
                    // Gray/Empty
                } else {
                    ctx.fillStyle = txt;
                    ctx.font = "700 10px 'JetBrains Mono'";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(cell.s, x + (CELL_W / 2), y + (CELL_H / 2));
                }
                
                // Highlight current active cell
                if(dataColIdx === currentColumn) {
                    ctx.strokeStyle = "rgba(255, 204, 0, 0.3)";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x,y,CELL_W, CELL_H);
                }
            }
        }
    }
    
    // Draw Current Time Indicator (Vertical line at end)
    const rightEdge = (maxVisibleCols-1) * CELL_W;
}

window.onload = () => {
    window.onresize();
    connect();
    draw();
};
</script>
