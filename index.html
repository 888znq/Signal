<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EURUSD WIN PREDICTOR - PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700;800&display=swap');

        :root {
            --bg-primary: #050505;
            --bg-secondary: #111111;
            --border-medium: #333333;
            --text-primary: #e0e0e0;
            --text-dim: #666666;
            --accent-red: #ff3b30;
            --accent-green: #34c759;
            --accent-gold: #ffcc00;
            --bar-size: 36px; 
            --w-streak: 60px;
            --w-index: 60px;
            --w-hunter: 220px;
            --w-sidebar: calc(var(--w-streak) + var(--w-index) + var(--w-hunter));
        }

        * { margin:0; padding:0; box-sizing:border-box; }
        
        body, html { 
            background-color: var(--bg-primary); 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden; 
            font-family: 'JetBrains Mono', monospace; 
            color: var(--text-primary); 
            touch-action: none; 
        }

        #ui { 
            position: fixed; top: 0; left: 0; right: 0; height: var(--bar-size); 
            background: var(--bg-secondary); border-bottom: 1px solid var(--border-medium); 
            padding: 0 15px; z-index: 1000; display: flex; align-items: center; justify-content: space-between; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        #app-container { display: flex; height: 100vh; padding-top: var(--bar-size); }
        
        #stage { flex: 1; position: relative; background: var(--bg-primary); overflow: hidden; }
        
        canvas { display: block; width: 100%; height: 100%; cursor: grab; user-select: none; }
        canvas:active { cursor: grabbing; }

        #sidebar { 
            width: var(--w-sidebar); background: var(--bg-secondary); 
            border-left: 1px solid var(--border-medium); display: flex; height: 100%; z-index: 100;
        }

        #col-streak { width: var(--w-streak); border-right: 1px solid var(--border-medium); overflow: hidden; }
        #col-index { width: var(--w-index); border-right: 1px solid var(--border-medium); background: var(--bg-secondary); overflow: hidden; }
        #col-hunter { width: var(--w-hunter); display: flex; flex-direction: column; background: var(--bg-secondary); }

        .streak-row { display: flex; width: 100%; border-bottom: 1px solid #222; cursor: pointer; }
        .streak-col { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 800; }
        .red-side { background: rgba(255, 59, 48, 0.05); color: var(--accent-red); }
        .green-side { background: rgba(52, 199, 89, 0.05); color: var(--accent-green); }
        .index-cell { width: 100%; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: var(--text-dim); border-bottom: 1px solid #222; }

        .hunter-body { flex: 1; overflow-y: auto; padding-bottom: 50px; }
        .h-row { padding: 12px 10px; border-bottom: 1px solid var(--border-medium); cursor: pointer; transition: 0.2s; }
        .h-row:hover { background: #1a1a1a; }

        @keyframes pulse-gold {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); color: #fff; }
            100% { opacity: 0.8; transform: scale(1); }
        }
        .pulse-val { animation: pulse-gold 1.5s infinite; color: var(--accent-gold); font-weight: 800; }

        #modalOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; backdrop-filter: blur(4px); }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 320px; height: 450px; background: var(--bg-secondary); border: 1px solid var(--border-medium); z-index: 2001; flex-direction: column; }
        
        #followBtn {
            background: var(--bg-tertiary); border: 1px solid var(--border-medium); 
            color: var(--text-dim); padding: 4px 10px; font-size: 10px; 
            font-weight: 700; cursor: pointer; border-radius: 4px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-weight:800; font-size:11px; letter-spacing:1px;">WALLSPECTRUM <span style="color:var(--accent-gold)">WIN PREDICTOR</span></div>
    <div style="display:flex; align-items:center; gap:15px;">
        <button id="followBtn" onclick="toggleFollow()">FOLLOWING</button>
        <div id="priceTag" style="color:var(--accent-green); font-weight:bold; font-size:13px; font-variant-numeric: tabular-nums;">CONNECTING...</div>
    </div>
</div>

<div id="app-container">
    <div id="stage">
        <canvas id="matrixCanvas"></canvas>
    </div>
    <div id="sidebar">
        <div id="col-streak"></div>
        <div id="col-index"></div>
        <div id="col-hunter">
            <div style="padding:8px; font-size:9px; color:var(--text-dim); border-bottom:1px solid var(--border-medium); text-align:center; font-weight:bold;">TOP SIGNALS</div>
            <div class="hunter-body" id="hunterList"></div>
        </div>
    </div>
</div>

<div id="modalOverlay" onclick="closeModal()"></div>
<div id="modal">
    <div id="modalTitle" style="padding:12px; text-align:center; border-bottom:1px solid var(--border-medium); font-size:11px; font-weight:800; color:var(--accent-gold);"></div>
    <div style="flex:1; display:flex; overflow:hidden;">
        <div id="rD" style="flex:1; overflow-y:auto; border-right:1px solid #222;"></div>
        <div id="gD" style="flex:1; overflow-y:auto;"></div>
    </div>
    <button onclick="closeModal()" style="padding:10px; background:transparent; border:none; border-top:1px solid var(--border-medium); color:var(--text-dim); cursor:pointer; font-family:inherit; font-size:10px;">CLOSE</button>
</div>

<script>
    const canvas = document.getElementById('matrixCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const SYMBOL = "frxEURUSD";
    const DERIV_WS = "wss://ws.derivws.com/websockets/v3?app_id=1089";

    const CELL_W = 45;      
    let CELL_H = 16;        
    const MAX_COLS = 7200; 

    let matrixData = {};
    let currentColumn = 0;
    let activeSecond = 0;
    let lastPrice = 0;
    
    let cameraX = 0;
    let isFollowing = true;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartCameraX = 0;

    const ENGINE = Array.from({ length: 60 }, (_, i) => ({
        id: i, bucket_ts: 0, open: 0, close: 0,
        prev_color: 'Gray', prev_streak: 0,
        live_color: 'Gray', live_streak: 0,
        history: { Red: {}, Green: {} }
    }));

    const pad = (n) => String(n).padStart(2, '0');

    // Helper to keep coordinates small (DNA Logic)
    function getWeekProgress() {
        const now = new Date();
        const day = now.getDay();
        const secsToday = (now.getHours() * 3600) + (now.getMinutes() * 60) + now.getSeconds();
        // Simple continuous counter for the week
        // 0 = Sunday, 1 = Monday... 
        // We just need a number that increases every second and resets weekly/daily to keep X small
        // Using a simple epoch modulo is safer for this specific visualizer
        return Math.floor(Date.now() / 1000); 
    }

    function processTick(price, epoch) {
        document.getElementById('priceTag').innerText = price.toFixed(5);
        const tag = document.getElementById('priceTag');
        tag.style.color = price > lastPrice ? '#34c759' : (price < lastPrice ? '#ff3b30' : '#e0e0e0');
        lastPrice = price;

        activeSecond = epoch % 60; 

        ENGINE.forEach(s => {
            const bucket = Math.floor((epoch - s.id) / 60) * 60 + s.id;
            if (bucket > s.bucket_ts) {
                if (s.bucket_ts !== 0) {
                    const color = s.close > s.open ? 'Green' : (s.close < s.open ? 'Red' : 'Gray');
                    if (color !== 'Gray') {
                        if (color === s.prev_color) s.prev_streak++;
                        else { s.prev_color = color; s.prev_streak = 1; }
                        s.history[color][s.prev_streak] = (s.history[color][s.prev_streak] || 0) + 1;
                    } else { s.prev_streak = 0; s.prev_color = 'Gray'; }
                }
                s.bucket_ts = bucket; s.open = price; s.close = price;
            } else { s.close = price; }

            const lColor = s.close > s.open ? 'Green' : (s.close < s.open ? 'Red' : 'Gray');
            if (lColor === 'Gray') { s.live_streak = s.prev_streak; s.live_color = s.prev_color; }
            else if (lColor === s.prev_color) { s.live_streak = s.prev_streak + 1; s.live_color = lColor; }
            else { s.live_streak = 1; s.live_color = lColor; }
        });
    }

    function handleTick(tick) {
        const now = tick.epoch;
        processTick(tick.quote, now);
        
        // FIX: Use Modulo to keep column index within 0-7200 range
        // This ensures the X coordinate never exceeds what the browser can draw
        const weekSecs = getWeekProgress();
        currentColumn = Math.floor(weekSecs / 60) % MAX_COLS;

        if (!matrixData[currentColumn]) matrixData[currentColumn] = {};

        ENGINE.forEach(s => {
            matrixData[currentColumn][s.id] = {
                c: s.close > s.open ? (s.close > s.open ? 'G' : 'R') : (s.close < s.open ? 'R' : 'N'), 
                s: s.live_streak
            };
        });
        
        updateSidebar();
        if(isFollowing) jumpToCurrent();
    }

    function jumpToCurrent(){ 
        const stageW = canvas.width / window.devicePixelRatio;
        cameraX = Math.max(0, (currentColumn * CELL_W) - stageW + (CELL_W * 2)); 
    }

    function toggleFollow() {
        isFollowing = !isFollowing;
        const btn = document.getElementById('followBtn');
        btn.innerText = isFollowing ? "FOLLOWING" : "RESUME FOLLOW";
        btn.style.color = isFollowing ? "#34c759" : "#666";
        if(isFollowing) jumpToCurrent();
    }

    canvas.addEventListener('mousedown', (e) => {
        isDragging = true; dragStartX = e.clientX; dragStartCameraX = cameraX;
        isFollowing = false; document.getElementById('followBtn').innerText = "RESUME FOLLOW";
        document.getElementById('followBtn').style.color = "#666";
    });
    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        cameraX = Math.max(0, dragStartCameraX + (dragStartX - e.clientX));
    });
    window.addEventListener('mouseup', () => { isDragging = false; });
    
    canvas.addEventListener('touchstart', (e) => {
        isDragging = true; dragStartX = e.touches[0].clientX; dragStartCameraX = cameraX;
        isFollowing = false; document.getElementById('followBtn').innerText = "RESUME FOLLOW";
        document.getElementById('followBtn').style.color = "#666";
    });
    window.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        cameraX = Math.max(0, dragStartCameraX + (dragStartX - e.touches[0].clientX));
    });
    window.addEventListener('touchend', () => { isDragging = false; });

    function updateSidebar() {
        let hS = '', hI = '';
        const liveData = matrixData[currentColumn] || {};

        for (let r = 0; r < 60; r++) {
            const cell = liveData[r];
            let rVal = '--', gVal = '--';
            let isRed = false, isGreen = false;
            let isActive = (r === activeSecond); 

            const eng = ENGINE[r];
            const liveC = eng.close > eng.open ? 'Green' : (eng.close < eng.open ? 'Red' : 'Gray');
            const val = eng.live_streak > 0 ? eng.live_streak : '--';

            if(liveC === 'Red') { rVal = val; isRed = true; }
            if(liveC === 'Green') { gVal = val; isGreen = true; }

            const rowStyle = isActive ? 'border: 1px solid var(--accent-gold); background: #222;' : '';
            
            hS += `<div class="streak-row" onclick="openModal(${r})" style="height:${CELL_H}px; ${rowStyle}">
                <div class="streak-col red-side" style="${isRed ? 'opacity:1; color:#fff; background:var(--accent-red);' : ''}">${rVal}</div>
                <div class="streak-col green-side" style="${isGreen ? 'opacity:1; color:#fff; background:var(--accent-green);' : ''}">${gVal}</div>
            </div>`;

            hI += `<div class="index-cell" style="height:${CELL_H}px; ${isActive ? 'color:var(--accent-gold); font-weight:900;' : ''}">${pad(r)}_${pad(r)}</div>`;
        }
        document.getElementById('col-streak').innerHTML = hS;
        document.getElementById('col-index').innerHTML = hI;
        scanBestWalls();
    }

    function scanBestWalls() {
        let walls = [];
        ENGINE.forEach(s => {
            ['Red', 'Green'].forEach(color => {
                const counts = s.history[color];
                for (let x = 2; x < 15; x++) {
                    const cur = counts[x] || 0;
                    const nxt = counts[x + 1] || 0;
                    if (cur >= 1) { 
                        const wr = (1 - (nxt / cur)) * 100;
                        const score = wr * Math.log10(cur + 1); 
                        if(wr > 0) {
                            walls.push({
                                id: s.id, color, level: `X${x}â†’X${x+1}`, 
                                wr, cur, score, 
                                pred: color === 'Red' ? 'CALL' : 'PUT' 
                            });
                        }
                    }
                }
            });
        });

        walls.sort((a, b) => b.score - a.score);
        document.getElementById('hunterList').innerHTML = walls.slice(0, 15).map(w => `
            <div class="h-row" onclick="openModal(${w.id})">
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                    <span style="color:var(--accent-gold); font-size:11px; font-weight:800;">${pad(w.id)}_${pad(w.id)}</span>
                    <span class="pulse-val" style="font-size:11px;">${w.wr.toFixed(0)}% WIN</span>
                </div>
                <div style="display:flex; justify-content:space-between; font-size:10px;">
                    <span style="color:${w.color==='Red'?'var(--accent-red)':'var(--accent-green)'}; font-weight:bold;">${w.level}</span>
                    <span style="color:var(--text-dim);">VOL: ${w.cur}</span>
                </div>
            </div>
        `).join('') || '<div style="padding:20px; text-align:center; font-size:10px; color:#444;">ANALYZING...</div>';
    }

    function draw() {
        requestAnimationFrame(draw);
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.width / dpr;
        const h = canvas.height / dpr;
        
        ctx.fillStyle = "#050505";
        ctx.fillRect(0, 0, w, h);

        ctx.save();
        ctx.translate(-cameraX, 0);

        const startCol = Math.floor(cameraX / CELL_W);
        const endCol = Math.floor((cameraX + w) / CELL_W) + 1;

        for (let i = startCol; i <= endCol; i++) {
            const x = i * CELL_W;
            // Handle wrapping for infinite scroll illusion if needed, but strictly 
            // mapping to currentColumn for now is safest.
            const colData = matrixData[i];

            ctx.strokeStyle = "#1a1a1a";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();

            for (let r = 0; r < 60; r++) {
                const y = r * CELL_H;
                if (colData && colData[r]) {
                    const cell = colData[r];
                    let bg = '#0a0a0a'; 
                    let txtColor = '#333';
                    
                    if (cell.c === 'R') { bg = 'rgba(255, 59, 48, 0.2)'; txtColor = '#ff3b30'; }
                    if (cell.c === 'G') { bg = 'rgba(52, 199, 89, 0.2)'; txtColor = '#34c759'; }
                    if (cell.c === 'N') { bg = '#111'; txtColor = '#222'; }

                    ctx.fillStyle = bg;
                    ctx.fillRect(x + 1, y + 1, CELL_W - 2, CELL_H - 2);

                    if (cell.s > 0) {
                        ctx.fillStyle = txtColor;
                        ctx.font = "bold 10px 'JetBrains Mono'";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(cell.s, x + CELL_W / 2, y + CELL_H / 2);
                    }
                }
            }

            if (i === currentColumn) {
                ctx.strokeStyle = "rgba(255, 204, 0, 0.3)";
                ctx.lineWidth = 1;
                ctx.strokeRect(x, 0, CELL_W, 60*CELL_H);
                
                const scannerY = activeSecond * CELL_H;
                ctx.fillStyle = "rgba(255, 204, 0, 0.2)";
                ctx.fillRect(x, scannerY, CELL_W, CELL_H);
                ctx.strokeStyle = "#ffcc00";
                ctx.strokeRect(x, scannerY, CELL_W, CELL_H);
            }
        }
        ctx.restore();
    }

    window.openModal = function(id) {
        const s = ENGINE[id];
        document.getElementById('modalTitle').innerText = `OFFSET ${pad(id)} HISTORY`;
        const render = (obj, c) => Object.keys(obj).sort((a,b)=>b-a).map(k => 
            `<div style="padding:8px; border-bottom:1px solid #222; font-size:11px; display:flex; justify-content:space-between;">
                <span style="color:${c}; font-weight:bold;">Streak ${k}</span>
                <span>${obj[k]} hits</span>
            </div>`).join('');
        document.getElementById('rD').innerHTML = render(s.history.Red, '#ff3b30');
        document.getElementById('gD').innerHTML = render(s.history.Green, '#34c759');
        document.getElementById('modal').style.display = 'flex';
        document.getElementById('modalOverlay').style.display = 'block';
    };

    window.closeModal = function() {
        document.getElementById('modal').style.display = 'none';
        document.getElementById('modalOverlay').style.display = 'none';
    };

    window.onresize = () => {
        const stage = document.getElementById('stage');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = stage.clientWidth * dpr;
        canvas.height = stage.clientHeight * dpr;
        ctx.scale(dpr, dpr);
        CELL_H = stage.clientHeight / 60;
        updateSidebar();
        if(isFollowing) jumpToCurrent();
    };

    function connect() {
        let ws = new WebSocket(DERIV_WS);
        ws.onopen = () => ws.send(JSON.stringify({ ticks: SYMBOL, subscribe: 1 }));
        ws.onmessage = (m) => { const d = JSON.parse(m.data); if (d.tick) handleTick(d.tick); };
        ws.onclose = () => setTimeout(connect, 3000);
    }

    window.onload = () => { window.onresize(); connect(); draw(); };
</script>

</body>
</html>
